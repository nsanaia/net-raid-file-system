Nodar Sanaia

OS Final


გაშვების ინსტრქუქციუა Readme-ში წერია!!!


config

config  ფაილის დაპარსვა მარტივად fscanf-ით შევძელი.
რაც configში უნდა რქმეოდა სტრუქტურაშიც დაახლოებით ის დავაქრვი
დაპარსაა ამ კონფიგის ფაილის ხდება პროგრამის გაშვების დაწყებასტან ერთად.


typedef struct{
    char * diskname;// = STORAGE1
    char * mountpoint; // = /path/to/mountpoint1
    int raid;//= 
    int servers_num;
    char ** servers;// = 127.0.0.1:10001, 127.0.0.1:10002
    char * hotswap;////= 127.0.0.1:11111 
}disk_struct;

typedef struct{
    char * errorlog;// = /path/to/error.log
    int cache_size;// = 1024M
    char * cache_replacment;// = rlu
    int timeout;// = 10
    int disks_num;
    disk_struct * disks;//disk array
}config_struct;




იერარქიუილი დირექტორიის სტრუქტურა



ამისთვის გადატვირტულია fuse-ის მეთოდები, რომლებიც უშუალოდ სერვერთან გადიან კავშირზე და აძლევენ სწორედ იმ დატას,
რომელიც ფაილის შექმნას, ფაილსი წაშლას, გახნსა, დირექტორიის გახნსას და ასე შემდეგ გულისხომბს. 
პირველი რაც გავაკეთე იყო ის რომ, შემოვიღე რაღად default  protocol_struct, რომელიც ყველა ფუნქიის საწყის request-ს დატას ერგება.
struct protocol_struct
{

    char current_name[256];
    char old_name[256];
    size_t newsize;
    size_t size;
    mode_t mode;
    off_t offset;
    int fh;
    int function_id;
    int flags;
    int write_flag;
    DIR *dp;
};

ყველაზე მთავარი ამ protocol_struct-ში არის სწორედ function_id, რომელიც სერვერს ეუბნება რომელი მეთოდი შეასურლოს.
მაგლითად mkdir კლიენტის მხარეს ააწყობს თავის request-ს და function_id-დ ადაუსეტავს იმ იდენტიფიკატორს, რომელიც მხოლოდ mkdir-სთვისაა დამახსიათებელი.
სერვერის while-ში იღებს request-ებს და ნახულობს ესა თუ ის id და შესაბამისად უშვებს სწორედ იმ ფუნქციას, რომელიც request-ში მიიღო.


ამგვარად ხდება მეთოდების განსხვავება და ჰენდლინგი.

ამ სტრუქტურაში დამდატებულია ის პარამეტრები, რაც თითოეულ მეთოდს დაჭირდა.

მაგლითად rename-ს დაჭირდა old_name და current_name სერვერს რო გაეგო და ამიტომაც ჩაემატა ამ სტრუქტურაში.
ასეა დამატებული ყველა ელემენტარული ცვლადი.

დამატებულია ასევე რამდენიმე სტრუქტურა რათა სერვერიდან  არ მომიხდეს ბევრჯერ response-ის დაბრუნება.
ამგვარად ბევრად სწრაფი იქნება.
struct getattr_response
{
	struct stat statbuf;
	int res;
};

struct readdir_response
{
	int res;
	int len;
};

struct opendir_response
{
	int res;
	DIR *dp;
};

struct server_iterator_response
{
	int function_id;
	char path[512];
};




Mirroring

გვაქვს 1 მთავარი სერვერი და მეორე არამთავარი ნაკადი.
მთავარი მნიშვნელობა იმიტო შევძინე, რომ პირველად ამ მთავარ სერვერზე იგზავნბვა request შემდეგ მეორეზე
და მეორეს დანიშნულება stable storage-ია. ამიტომ opendir, readdir და მსგავსი ფუნქციაები მეორე სერვერზე არ იძახება. 
იძახება მხოლოდ ის ფუნქციები, რომლებიც ცვლის ფაილების იერაქიის სტრუქტურას, ფაილსი კონტენტს და ასე შემდეგ.
ამიტომ მეორე სერვერი იდენტურია პირველის.


stable storage-ისთვის ფაილის extend ატრიბუტებს ვიყენებ. სერვერზე ხდება აფილის კონტენტის დაჰეშვა md5 ჰეშით(stack overflow-ს კოდით)
და შედეგ ამ ატრიბუტებში დასეტვა მისი კერძოდ mknod-ში და write-ში.
stable storage-ის მთავარი ლოგიკა სწორედ open-ში ხდება.
სერვერის მხარეს თავიდან ვჰეშავ ამ აილის კონტენტს და კლეინტს ვუგზავნი ძველ და ახალ ჰეშებს.

ხოლო კლეინტში ხდება უკვე მათი დამუშავება. 
კლეინტს ამ დროს ორი სერვერიდან აქვს შესაბამისად თავისი ძველი და ახალიო ჰეშები.

ხდება უკვე მათი ლოგიკური შედარება.

პირველი შემთხვევაად განვიხილე როდესაც მთავარ სერვერზე საჭიროა აღდგენა მეორე სერვერიდან.
ანუ პირველი ძველი და ახალი ჰეშები არ ეთხვევა ერმანეთს ხოლო მეორის ემთხევა.
ანუ პირველში არავალიდური ფაილის კონტენტია და მეორე ვალიდური
ამიტომ გადმოვწეროთ პირველში მეორეს კონტენტი.

შემდეგი ქეისი არის როდესაც მეორეს ძველი და ახალი ჰეშები არ ემთხვევა ანუ არავალიდურია.
ამიტომ პირველიდან გადმოვწეროთ მეორეში. 
ამ შემთხვევაში ისიც მოვიაზროთ ბარემ რომ პირველის
ძველი და მეორის ძველი თუ არ ეთხვევა. ამ შემთხვევაში მეორეას პირველთან მიმართებაში არავალიუდი ფაილი აქვს და ბარემ
შედარებით ვალიდური გავხადოთ და ამიტომაც ისევ პირველიდან მეორეში გადავწეროთ.


ბოლოს არის შემთხვევა როდესაც პირველის ძველი არ ურდის ახალს და არავლაირუდია
და იგივენაირად არავალირუია მეორე ფაილიც
ანუ აღდგენის საშუალება აღარ გვრჩება ამიტომ წავშალოთ საერთოდ ორივეგან ეს ფაილი.
შედარებით სწორი solution მგონია მე.





მაღალმდგრადობა


შემოვიღე 2 ნაკადი.

სანამ ავსნი თითოულის აზრს, მანამდე გავიხსენოთ სხვაობა მთავრ და არამთვარ სერვერში.(ჰოთსვაპის გარეშე).
გვაქვს 1 მთავარი სერვერი და მეორე არამთავარი ნაკადი.
მთავარი მნიშვნელობა იმიტო შევძინე, რომ პირველად ამ მთავარ სერვერზე იგზავნბვა request შემდეგ მეორეზე
და მეორეს დანიშნულება stable storage-ია. ამიტომ opendir, readdir და მსგავსი ფუნქციაები მეორე სერვერზე არ იძახება. 



ყოლელივე ამის გათვალიწინებით და კიდე იმის რომ 10 წამის განმავლობაში აღდგენას უნდა ეცადოს კავშირის და თან ჩაწერა-წაკითხვა შესაძლებელი უნდა იყოს 
გადავწყიტე რომ თუ ეს მთავარი სერვერი გაითიშებოდა, მაშინ მეორე ცოცლი სერვერით ჩამენაცვლებინა, და იმაზე გადამისამერთებულიყო opendir და მსგვასი request-ები
და დანარჩენ ფუნქციებშიც პირველად იმაზე მომხდარიყო ჩაწერა. ამ დროს კლეიტნი ვეღარ ატყობს ერთ-ერთი სერვერის გაჩერებას.
ამას გადამისამრთბეას და სერერის ჩართულობის შემოწმებას აკეთებს პირველი ნაკადი.

ხოლო გადამისამრთებული გათიშული სერვერის აღდგენაზე უკვე მეორე ნაკადი ზრუნას. ეს ასევე იმ შემთხვევასაც გაითვალსიწნებს, რომ ეს სერვრი შეიძლება გადმომისამართებული არცაა
და ისე გაითიშა ანუ მეორე არამთავარი სერვერი იყო.

მოკლედ რაღაც კონფიგის timeout დროის განმავლობაში ხდება სერვერთა კავშირის დამყარების მცდელობები.


ამ დროს გვაქვს 2 შემთხვევა.

* პირველი როდესაც აღდგა
* მეორე როდესაც ვერ აღდგა


დავიწყოთ პირველი შემთხვევიდან

სანამ ამ ქეისის განხილვას დავიწყებ ამ timeout დროის განმავლობაში stable storage-ის შენარჩუნება თითქმის შეუძლებელია, რადგან მეორე სერვერი აღარ მუშაობს
და მეც შესაბამისად stable storage ამ დროს აღარ მაქვს სანამ კავშირი არ აღდგება.

თუ აღდგა კავშირი ამ მეორე სერვერთან და გასულია t დრო გათშვიდან, ამ t დროის განმავლობაში სერვერს მომხადარი eventების(მაგლითად ჩაწერა წაკითხავა)
შეასახებ ინფორმაცია არ აქვს აიმტო საჭირო გახდა სადრაც მეხსირებაში შენახვა ამ event-ების. 
ამისთვის შემოვიღე  სტრუქტურა not_resolved_events, რომელიც შედგება იმ გასაგზავნი request-ებისაგან, რომლებიც t დროის განმავლობაში 
მეორე სერვერმა არ იცოდა. len და log_len საჭირო გახდა ამ მასივისთის(ტექნიკური დეტალებია).

struct not_resolved_events
{
    int log_len;
    int len;
    struct protocol_struct *content;
};

სერვერთან კავშირის დამყარების მცდელობისას t დროის განმავლობაში ვგროვებთ ამ request-ებს და როდესაც  
სერვერთან კავშირი ღდგება, ერთიანად ვაგზავნი ყველა ამ request-ს. თითქოს ყველაფერი იდენტური ექნებათ მთავარ
და ამ მეორე სერვერს მაგრამ რაღაც სხვაობა იქნება და ამას ავსნი.
მოკლედ ეს დაგროვებული requestები სწორედ ის default რექვესტებია და არ შეიცავს write-ის request-ს, რომელიც დიდი ზომის buffe-ისგან შედგება და მსგავს გამონაკლს request-ებს.
ანი რეაურად ჩვენს მასივში არ გვაქვს writeის request. 
ჩნდება კითხვა, რომ ვიღაცამ რო რაღაცა ჩაწერა მეორე სერვერზე საიდან უნდა მოვიდეს.
მთელი დედაზრი სწორედ ის არის რომ მეორე სერვერზე 100%ით სწორადაა ფაილების, დირექორების, და ფოლდერების განგალება და ერთიერთმიმართება.


ხოლო უშუალოდ კლიენტი რომ გახსნს ფაილს ამასობაში უკვე stable storage-ც ამუსავებულია
და სწორედ ის მოაგვარებს ამ პრობლემას. ცარიელ ფაილში ადგება და მთლიანად გადმოწერს
პირველი ფაილის კონტენტს.

ეს მიდგომა კიდევ იმითაა კარგი რომ ერთიანად მთელი სერვერის კოპირებას დიდი დრო დაჭირდებ
ფაილებიანად. ახლა კი დინა,მიურად დაგნერიდება მეორე სერვერი.
მთავატი ჩონჩხი
დირექტორიების სტრუქტურა უკვე მზად იქნება და ფაილბის განახლება არარც იქება პრობლემა.





ახლა განვილოთ მეორე შემთხვევა, როდესაც კავშირი ვეღარ აღდგა
აქ უკვე შემოდის hotswap სერვერ, რომლისთვისაც უნდა გადავიტანოთ მთელი მთავარი პირველი სერვერი.
ამისთვის ამ მთავრ სერვერზე ვაგზავნით request-ს რომ ყველა არსებული ფაილი თუ ფოდრეი წამოვიღოთ და 
მეორე სერვერზე შევქმნათ.

მთვარი სერვერიდან წამოღებულ ამ ინფორმაციას ვაწყობთ ისევე რაღაც not_resolved_eventsებს და ვაგზავნით  hotswap-ის სერვერზე. 
აქაც მოლოდ ჩონჩს ვაწყობთ. დირექტორიის სტრუქტურას და შემდეგ კლიენტის openს ველოდებით და stable storage უკვე თავისით აგვაებს საქმეს.



ქეშირება
 
პროექტში ნაკლები შეცდომის დასაშვებად და მოდულრალური კოდის დასაწერად ქეშირების შიდა ლოგიკის დაწერა ცაკლე ფაილში გადავწყვიტე.
ამიტომ შექმნილია cache.h და cache.c ფაილები.

h ფაილში არწერილია ყველა ის ფუნქცია და სტრუქტურა, რაც შეიძლება გარედან იქნეს გამოყენებული.

ესენია 
struct cache_item{
    char name[256];
    off_t offset;
    size_t size;
    char * content;
    struct cache_item * next;
};

struct cache_base {
    int log_size;
    int max_size;
    struct cache_item * next;
};

void cache_init(struct cache_base * base, int max_len_); 
int cache_add(struct cache_base * base, const char * name_ , off_t offset_, size_t size_, char * content_ );  
int cache_find(struct cache_base * base, const char * name_  ,off_t offset_, size_t size_, char * content_ );
void cache_rename(struct cache_base * base, const char * name_ );
void cache_remove(struct cache_base * base, const char * name_ );
void cache_destroy(struct cache_base * base);




მოკლედ ქეშის მთავარი სტრუქტურა(cache_item) შედგება გამოყენებული მეხსიერებისაგან(log_size), შესაძლო მაქსიმალური მეხისერებისაგან (max_size), და linked  list-ისაგან (next).

linked list თითიეული ელემენტი არის  cache_item სტრუქტურა, რომელიც თავისთავად მოიცავს რომელ ფაილს შეესაბამება ესე თუ ის ქეშის ელემენტი(cache_item),
                                                                                             ამ ფაილში რა დაშორებიდან(offset) იწყება დაქეშილი კონტენტი არის 
                                                                                             ამ დაშორებნიდან რა ზომის(size) ნაწილია დაქეშილი 
                                                                                             უშუალოდ კონტენტი თუ რა გვაქ დაქეშილი content
                                                                                            და რადან linked list-ის ნაწილია შემდეგ ელემენტზე მიმთითებელი(next)


ქეშის linkd list-ით დაწერა იმიტომ გადავწყვიტე, რომ ელემენტის ამოშლა ძან მარტივია(წინას ამ ელემენტის შემდეგს მივუთთებთ, შუას გავასუფთავებთ)



ალხა უშუალოდ პროექტში ამ ქეშის გამოყენება:

ქეშის ინიციალიზაცია(cache_init) ხდება diskების ინიციალიზაციასთან ერთად ანუ mainშივე.

ქეშის განახლება ხდება read, write, rename, unlink.


readში ხდება პირველ რიგში გადმოცემული ფაილის სახელით ქეშში ელენტის ძებნა(cache_find) ძებნა ხორციელბდა შედარებით ოპტიმალურად
რადგან ქეშში ელემენტის offset-დან  ( offset + size )-მდე თუ მოექცა გადმოცემული readშ-ში გადმოცემული offset და size და სახელებიც დამეთხვა
ეს ნიშნავს რომ ჩვენი დაქეშილი კონტენრი ამას მოიცავს და გვიპოვაი. ამიტომ პირდაპირვე დავუბრუნებთ მომმარებელს შესაბამის კონტენტს.
ხოლო თუ ქეშში ვერ ვიპოვეთ. ტრადიიულ ხერხს მივმართავთ ანუ სერვერზე request-ს გავაგზავნით და იქიდან დაბრუნებულ პასუხს უკვე 
ჩვენ ქეშში ჩავამატებთ(cache_add) შემდეგი read-სთვის.

cache_addში ხდება გამოყენებული მეხსიერების ვალიდირება. ანუ თუ ქეშის დაკავაბული მეხისრებამ გადააწარბა ან ტოლია  მაქსუმალურ დასაკავებელ მეხისრებას, 
მაშინ ვშლით იმდენ პირველ ელენეტს(LRU-s ალგორითმი, ყველაზე ადრინდელი ჩაგდებული უნდა წაიშალოს ჩვენთან კი ისინი linked list-ის  თავიდან ბოლოსკენ ქრონოლოგიურად დალაებულია ზრდადობით)
რომ ახალ დასაქეშ ელემენტს გაუნთავისუფლდეს საკმარისი ადგილი. ამაში linked list-იც ძან კომფორული აღმოჩნა base ელემენტებს ვამისამართებთ შემდეგის შემდგზე
და ამას ვასუფთავებთ. 

write-ში ხდება ფაილის conten-ის განხელბა შესაბამისად იცველაბ ჩვენი ქეშშის კონტენტიც. ამიტომ კარგი ვარიანტი იქნება თუ ამ ფაილის
ყველა ქეშის ელემენტს თუ წავშლით(cache_remove)

დაახლოებით იგივე შეიძლება ითქვას unlink მოცემული ფაილის სახლით ქეშში აღარ გჭირდება ამ ფაილის ელემენტები
და შესაბამისად წავშალოთ ქეშიდან ამ ფაილის ქეში ელემენტები(cache_remove)

rename-ში თუ ფაილს სახელი ეცვლება და ქეშში გვაქვს შემორჩენილი ამ ძველი სახელით cache_item,
მაშინ ყველა ამ ელემენტს სახელს შევუცვლით(cache_rename) და readის დროს ჩვეულებრივად წავიკითხავთ ქეშიდან სერვერის request-ის გარეშე.


მოკლედ ქეშის მუშაობის დრო  cache_init გარდა ყველა O(n)-ია.


 ლოგირება


ილოგება მნიშველობანი მოვლენები.

1. სერვერთან კავშირის დამყარება
2. სერვერთან ხელახალი კავშირის დამყარება
3. სერვრის გამოცხადება დაკარგულად
4. ყველა სერვერის გათიშვა, ანუ უკვე პროგრამა ვეღარ აგრძელებს მუშოაბას.



ლოგირებასათვის იმპლენეტირებულიუა შემდეგი ფუქნცია.


int _log(char *log_file_path, char *diskname, char *server, char *message)
{
    FILE *logfile = fopen(log_file_path, "a");
    if (logfile == NULL)
    {
        logfile = fopen(log_file_path, "w");
    }
    time_t rawtime;
    struct tm *timeinfo;
    time(&rawtime);
    timeinfo = localtime(&rawtime);
    char res_time[256];
    strcpy(res_time, asctime(timeinfo));
    res_time[strlen(res_time) - 1] = '\0';
    fprintf(logfile, "%s%s%s", "[", res_time, "]");
    fprintf(logfile, "%s%s", " ", diskname);
    fprintf(logfile, "%s%s", " ", server);
    fprintf(logfile, "%s%s", " ", message);
    fprintf(logfile, "\n");
    fflush(logfile);
}





epol


ეპოლი ესე ვთქვათ ინიცალიზდება შემდეგი ფუქნციით epoll_create(კლეიეტების რაოდნება), რომელსაც 
გადაეცამე კლეიენტების რაოდნება. და ეს ეპოლი თვითონ აუმჯობესებს მათ მომსახურებას, თუცმა
ჩვენს შემთხვევაში სულ ერთი კლეიენტია შესაბამისად epoll_create(1)ს ვიძახებთ.
გამოვიდა რომ კლეიტნების მომხასურებაში არჩევანი აღარ აქვს ეპოლს.
თუმცა მაინც დავაიმპლემენტირე ეპოლი მიუხედავად ზემოთ აღწერილისა.




მოკლედ raid 5-ს გარდა ყველაფერი წერია.













